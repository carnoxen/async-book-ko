# 왜 비동기가 필요한가?

우리모두는 러스트로 빠르고 안전한 소프트웨어를 작성할 수 있음을 잘 알고
있습니다. 왜 그런데도 비동기 코드를 작성해야 할까요?

비동기 코드는 우리가 한 개의 운영체제 스레드 위에서 여러 개의 태스크를 동시에
돌릴 수 있게 해줍니다. 전형적인 스레드 어플리케이션에서는 웹 페이지 두 쪽을
동시에 다운로드하고 싶을 때, 서로 다른 스레드 두 개에
작업을 나누어 배당합니다. 이렇게요.

```rust,ignore
{{#include ../../examples/01_02_why_async/src/lib.rs:get_two_sites}}
```

이 동작은 많은 어플리케이션에서 잘 돌아갑니다. 결국 스레드는 한 번에 여러
태스크를 수행하기 위해 만들어졌습니다. 하지만 이런 방법에는 한계가 있습니다.
서로 다른 스레드를 바꾸거나 스레드끼리 데이터를 공유하는 과정에서 많은
오버헤드가 발생하기 때문입니다. 만들어지고 나서 아무 것도 하지 않는 스레드가
귀중한 시스템 자원을 고갈시킬 수도 있습니다. 이러한 문제를 해결하기 위해 비동기
코드라는 것이 만들어졌습니다. 위 예제의 함수를 러스트가 지원하는 `async`/
`.await` 표기를 이용하여 다시 작성하면, 다수의 스레드를 만들지 않고 한 번에 여러
태스크를 수행할 수 있습니다.

```rust,ignore
{{#include ../../examples/01_02_why_async/src/lib.rs:get_two_sites_async}}
```

대체로 비동기 어플리케이션은 멀티스레드로 구현된 것보다 더 빠르면서 자원은 덜
사용할 것입니다. 그러나 한계도 있습니다. 스레드는 본디 운영체제 차원에서
지원하고, 어떤 특별한 프로그래밍 모델도 필요하지 않습니다. 어떤 함수라도
스레드를 만들 수 있으며, 스레드를 사용하는 함수를 부르는 것은 그렇지 않은 평범한
함수를 부르는 것처럼 쉽습니다. 하지만 비동기 함수는 언어나 라이브러리로부터
특별한 지원을 받아야 합니다. 러스트에서는 `async fn` 표기가 `Future`를 반환하는
비동기 함수를 만들 수 있습니다만, 실제 그 함수의 본체가 실행되기 위해서는 반환된
`Future`가 완성까지 수행되어야 합니다.

전형적인 스레드 어플리케이션이 매우 효과적일 수도 있으며, 러스트의 적은 메모리
사용과 예측 가능성 덕분에 `async`를 전혀 사용하지 않아도 훌륭한 성능을 낼 수
있음을 꼭 기억하시기 바랍니다. 비동기 프로그래밍 모델은 복잡성을 증대시키므로,
모든 상황에 적합한 것은 아닙니다. 따라서 여러분의 어플리케이션이 더 간단한
스레드 모델을 사용하는 게 더 좋을 수도 있다는 생각을 항상 가져야 합니다.
