# 비동기적 러스트 현황

비동기 러스트 중 일부는 동기적 러스트와 같은 수준의 안정성을 보장받고 있습니다.
나머지 부분들은 과도기에 있으며 향후 변경될 수 있습니다. 비동기 러스트에서는
아래와 같은 장단점들이 있습니다.

- 전형적인 병행 워크로드에서 뛰어난 런타임 성능
- 수명, 고정하기와 같은 러스트의 진보된 특징들과의 보다 빈번한 상호작용
- 동기, 비동기 코드에 걸쳐, 그리고 서로 다른 비동기 런타임에 걸쳐 보장되는 일부
  호환성
- 비동기 런타임과 언어지원이 발전됨에 따라 가중되는 유지보수 부담

요약하면, 비동기 러스트는 사용하기 좀 어려워서 동기적 러스트보다 유지보수 부담이
큽니다만, 최상의 성능을 얻을 수 있습니다.
비동기 러스트의 모든 영역이 지속적으로 발전하고 있으므로, 문제점들은
시간이 갈 수록 완화될 것입니다.

## 언어 및 라이브러리 지원

비동기 프로그래밍은 러스트가 직접 지원하는 기능이지만, 대부분의 비동기
어플리케이션은 커뮤니티가 주도하는 크레잇들에 의존하고 있습니다.
마찬가지로, 여러분도 러스트 언어 기능과 라이브러리 지원을 복합적으로 사용해야 할 것입니다.

- [`Future`](https://doc.rust-lang.org/std/future/trait.Future.html) 트레잇과
  같은 가장 기초적인 트레잇, 타입 그리고 함수는 표준 라이브러리에서 지원합니다.
- `async/await` 문법은 러스트 컴파일러가 직접 지원합니다.
- 수많은 유틸리티 타입, 매크로 그리고 함수들은
  [`futures`](https://docs.rs/futures/) 크레잇에서 지원합니다. 이것들은 모든
  비동기 러스트 어플리케이션에서 사용가능합니다.
- 비동기 코드, 입출력 그리고 작업 생성은 Tokio와 async-std 같은 "비동기
  런타임"에서 제공됩니다. 대부분의 비동기 어플리케이션과 몇몇 비동기 크레잇은
  특정 런타임에 의존합니다. 보다 자세한 내용은 ["비동기
  생태계"](../08_ecosystem/00_chapter.md) 장을 참조하세요.

여러분이 동기적 러스트에서 종종 사용했던 몇몇 러스트 기능들은 비동기
러스트에서는 아직 사용할 수 없습니다. 특히, 트레잇 안에서는 비동기 함수를
선언할 수 없습니다. 이같은 기능을 구현하려면 조금 번잡스러운 우회방법을 사용해야 합니다.

## 컴파일과 디버깅

비동기 러스트의 컴파일러와 런타임 에러들은 대부분 동기 러스트에서 작동했던
그것들과 같은 방식으로 작동합니다만, 주의할만한 차이점이 몇 개 있습니다.


### 컴파일 에러

비동기 러스트에서 컴파일 에러는 동기적 러스트에서의 같은 수준의 표준과
동일합니다만, 비동기 러스트가 수명이나 고정하기와 같은 좀더 복잡한 언어 기능을
사용하기 때문에, 이러한 에러가 좀더 빈번하게 나타날 것입니다.

### 런타인 에러

컴파일러는 비동기 함수를 맞닥트릴 때마다, 내부적으로 상태기계를 생성합니다.
비동기 러스트의 스택 추적들은 일반적으로 런타임의 함수호출 뿐만 아니라, 이런
상태기계의 세부사항을 포함합니다. 따라서, 스택 추적을 해석할 때도 동기적
러스트에서보다 더 고려할 것들이 있습니다.

### 새로운 실패 상황들

비동기 러스트에서는 몇가지 참신한 실패 상황들이 발생할 수 있습니다. 예를 들어,
블로킹 함수를 비동기 콘텍스트에서 호출하거나, `Future` 트레잇을 잘못 구현하는
경우들이 있습니다. 이같은 에러들은 컴파일러나 심지어 유닛 테스트에서도 발견되지
않을 수 있습니다. 이 책의 목표대로 여러분이 내부 컨셉과 구조를 완벽한
이해한다면, 이같은 문제들을 예방하는데 큰 도움이 될 것입니다. 

## 호환성 검토
비동기와 동기적 코드를 항상 자유롭게 섞을 수 있는 것은 아닙니다. 예를 들어,
동기적 함수에서 비동기 함수를 직접 호출할 수는 없습니다. 동기, 비동기 코드는
서로 다른 디자인 패턴을 추구하는 경향이 있고, 따라서 서로 다른 환경을 고려할 수
밖에 없는 코드들을 섞어서 사용하기는 어렵습니다.

비동기 코드끼리도 항상 자유롭게 섞어 사용할 수 있는 것은 아닙니다. 몇몇 크레잇은
특정한 비동기 런타임에 의존합니다, 보통 그런 경우, 특정한 비동기 런타임은 그런
크레잇들의 의존성 목록에 등재됩니다.

이러한 호환성 이슈들은 여러분의 선택지를 축소시키곤 합니다. 따라서 개발 초기에
어떤 비동기 런타임과 크레잇이 필요한지 충분히 고민하는 것이 좋습니다. 어떤
런타임을 한 번 사용하기 시작하면, 호환성에 대하여 많은 고민을 할 필요가 없을
것입니다.

## 성능 특성

비동기 러스트의 성능은 여러분이 사용하는 비동기 런타임의 구현에 달려 있습니다.
비동기 러스트 어플리케이션에 사용되는 런타임들이 상대적으로 새로울지라도,
대부분의 실제 워크로드에서 매우 잘 작동합니다.

대부분의 비동기 생태계가 _멀티 스레딩_ 런타임을 상정(想定)하였다고
말씀드렸습니다. 이렇게 하면 소위 저렴한 동기화라 불리는 싱글 스레딩 비동기 어플리케이션의 이론상 성능
이득을 맛보기 힘들것입니다. 다른 간과된 용례는 장치 드라이버나 GUI 어플리케이션,
기타 등등에 중요한 _지연시간에 민감한 태스크들_입니다. 이러한 태스크들은 적합한
스케쥴링을 위해 런타임에 의존하며, 운영체제 지원에 의존할 때도 있습니다.
향후 이러한 용례를 위한 라이브러리 지원의 향상을 기대하여도 좋을 것입니다.
