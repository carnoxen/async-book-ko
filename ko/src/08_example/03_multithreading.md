# 병렬적으로 요청에 대응하기
지금까지 우리 예제는 (스레드를 사용한) 병행성 대신에 (비동기 코드 사용한) 동시성을
제공하였습니다. 하지만, 비동기 코드와 스레드는 상호 배제적이지 않습니다. 비동기
executor는 싱글스레드나 멀티스레드 둘 중에 아무거나 될 수 있습니다. 예를 들어,
`async-std`에 사용되는 [`async-executor`
크레잇](https://docs.rs/async-executor)은 싱글스레드인 `LocalExecutor`와
멀티스레드인 `Executor` 둘 다 포함하고 있습니다.

태스크는 그 태스크를 만든 스레드 또는 별도의 스레드 모두에서 실행될 수 있습니다.
비동기 런타임은 보통 별도의 스레드에 태스크를 생성하는 기능을 제공합니다.
태스크가 별도의 스레드에서 실행되더라도 블로킹하지 않을 것입니다.

몇몇 런타임은 전용 스레드에 블로킹하는 태스크를 만드는 기능을 제공합니다. 이
기능은 다른 라이브러리의 동기적 코드를 실행하는 데 유용합니다. 태스크는 보통
`Send`이어야 하므로, 다른 스레드로 옮겨질 수 있습니다. 몇몇 런타임은 `Send`가
아닌 태스크를 스레드-로컬(TODO: 한 스레드에만 존재하는) executor에 만드는 기능도
제공합니다.

이 예제에서 `main` 함수 안의 `for_each_concurrent`는 한 스레드에서 모든 연결을
동시에 처리합니다. 대신에, 아래 `handle_connection`이 `Send`이면서 블로킹하지도
않기 때문에 `handle_connection`을 (TODO: 동시에) 실행할 새 태스크를 만들 수
있었습니다. `async_std::task::spawn`은 이런 용도에 사용됩니다.

```rust
{{#include ../../examples/08_05_final_tcp_server/src/main.rs:main_func}}
```

다음에는 동시 여러 요청을 처리하기 위해 동시성과 병행성 둘 다 사용해 볼 것입니다.
